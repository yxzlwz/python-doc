# 3.2 文件操作

## 文件的存储方式

在计算机中，文件是以**二进制**的方式保存在磁盘上的。

但是为什么你打开一个文件的时候你看到的是字符而不是二进制呢？

这是因为文本浏览器（记事本、VScode等）将文本按照一定的方式转换为二进制存储，又将二进制按照一定的方式转换为了你能看得懂的文本，这个过程我们称之为**编码和解码**。

一般情况下，我们根据文件是否可以被解码为有意义的纯文本文件，将文件分成了**文本文件**和**二进制文件**两类。通常在编程中，除了使用爬虫下载文件外，文本文件是我们所需要关注的重点。

## 文件基本读写操作

### 操作文件的套路

在计算机中要操作文件一共包含三个步骤：

1. 打开文件
1. 操作文件
1. 关闭文件

### 操作文本文件

#### 操作文本文件的流程

```python
f = open('[文件名]', '[打开方式]', encoding='[编码方式]')
# 其中编码方式并不是必要的，但是为了支持中文，一般我们会将其加上，并且指明编码方式为utf-8

f.xxx()
# 做你想做的

f.close()
# 让你的操作得以应用并保存
```

#### 文本打开文件的方式

| **方式** | **说明** |
| --- | --- |
| r | 只读方式。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常 |
| w | 只写方式。如果文件存在会被覆盖。如果文件不存在，创建新文件 |
| a | 追加方式。该文件已存在：文件指针将会放在文件的末尾。文件不存在：创建新文件进行写入 |
| r+ | 读写方式。文件的指针将会放在文件的开头。如果文件不存在，抛出异常 |
| w+ | 读写方式。如果文件存在会被覆盖。如果文件不存在，创建新文件 |
| a+ | 读写方式。文件已存在：文件指针将会放在文件的结尾。文件不存在：创建新文件进行写入 |

这张图片可以帮你快速选择文件的方式：

<img width="1182" height="702" alt="image" src="https://github.com/user-attachments/assets/efea2f1f-a667-44e7-a695-defd4985acfd" />

#### 对于文本文件的主要操作

| 操作 | 效果 |
| --- | --- |
| read() | 返回值为字符串。返回整个文件中的内容，不管文件有多大 |
| readline() | 返回值为字符串。返回指针所在的一行（包括结尾的`'\\n'`），指针下移一行 |
| write(something) | 参数类型为字符串。将`something`中的内容写在文件指针处。 |

#### 示例

##### 以只读方式打开文件

```python
# 1.打开文件
f = open('read.txt', 'w')  # 以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件

# 2. 写入文件
f.write('vvcat')

# 3.关闭文件
f.close()
```

##### 以只写方式打开文件

```python
# 1.打开文件
f = open('read.txt', 'w')  # 以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件

# 2. 写入文件
f.write('vvcat')

# 3.关闭文件
f.close()
```

##### 以追加方式打开文件

```python
# 1.打开文件
f = open('read.txt', 'a')  # 以追加方式打开文件。如果该文件已存在，文件指针将会放在文件的末尾。如果文件不存在，创建新文件进行写入

# 2. 写入文件
f.write('vvcat')

# 3.关闭文件
f.close()
```

### 操作二进制文件

简单提一嘴。操作二进制文件可能是爬虫下载文件等场景用到，一般不用再自己去操作一个二进制文件，你也整不明白啊……

```python
f = open('[文件名]', '[二进制文件打开方式]')
# 其中编码方式是不能加上的，因为你要读的就是二进制

f.[操作]
# 做你想做的

f.close()
# 让你的操作得以应用并保存
```

#### 二进制文件的打开方式

| **方式** | **说明** |
| --- | --- |
| rb | 只读方式。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常 |
| wb | 只写方式。如果文件存在会被覆盖。如果文件不存在，创建新文件 |
| ab | 追加方式。该文件已存在：文件指针将会放在文件的末尾。文件不存在：创建新文件进行写入 |
| rb+ | 读写方式。文件的指针将会放在文件的开头。如果文件不存在，抛出异常 |
| wb+ | 读写方式。如果文件存在会被覆盖。如果文件不存在，创建新文件 |
| ab+ | 读写方式。文件已存在：文件指针将会放在文件的结尾。文件不存在：创建新文件进行写入 |

操作基本同文本文件。

### write 操作的覆盖特性

不同于我们使用文本编辑软件的操作，`write`在写入内容时不会自动后移，而是直接覆盖。这里给一个简单的例子。

假设我们现在有这样一个文件，初始时指针在“2”对应的格子上（Python 中的文件指针对其的是一个字符或二进制位，而不是像文本编辑器那样对其字符的间隙）：

<img width="711" height="161" alt="image" src="https://github.com/user-attachments/assets/75933336-65cb-40fe-bb6d-5a0ae60dc9b2" />

现在我们`write('abc')`，指针会覆盖原本`'234'`的位置，并移动到第一行末尾。

<img width="716" height="170" alt="image" src="https://github.com/user-attachments/assets/1ded8d99-509e-4fd3-96d3-3a4408d510ec" />

再次写入`'def'`，文件内容会变成`'1abcdef78\n'`。注意，这里分成两行只是为了方便大家阅读，实际上文本文件中没有分行的概念的——`'\n'`就是实现分行的字符。
