# 3.5 函数（二）

## 不定长参数

我们现在来解答《函数（一）》中留下的悬念：`print`函数是如何接收不定数量的参数的？

让我们定义这样一个函数：

```python
def f(*args):
    print(args)

f(1, 2, 3)  # (1, 2, 3)
f('a', 2, True, 3.14)  # ('a', 2, True, 3.14)
f()  # ()
```

`args`是一个变量名，在前面加上`*`，接收所有的参数，保存为元组（即不可更改的列表）。我们可以通过常规的列表访问方式去访问`args`中的元素。

类似地，我们可以通过加上`**`接收形如`a=b`的传参：

```python
def f(*args, **kwargs):
    print(args, kwargs)

f(1, 2, c=3)  # (1, 2) {'c': 3}
f('a', 2, x=True, y=3.14)  # ('a', 2) {'x': True, 'y': 3.14}
f()  # () {}
```

可以看到，此处`kwargs`的类型是一个字典。

我们来看一下`print`函数的抽象定义，开头的问题也就一目了然了：

```python
def print(
    *values: object,
    sep: str | None = ...,
    end: str | None = ...,
    file: SupportsWrite[str] | None = ...,
    flush: Literal[False] = ...,
) -> None:
    ...
```

那么，不定长参数与其它参数传递的顺序和优先级是怎样的？

学到这里的同学们应该学着自己解决问题了，建议自己写几个案例试试或者搜索互联网资源。

~~真的不是我懒~~

## 匿名函数

Python 使用`lambda`来创建匿名函数。

- `lambda`只是一个表达式，函数体比`def`简单很多。
- `lambda`的主体是一个表达式，而不是一个代码块。仅仅能在`lambda`表达式中封装有限的逻辑进去。
- `lambda`函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。
- 虽然`lambda`函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。

`lambda`格式：

```python
# lambda 参数列表: 函数返回值
lambda [arg1 [,arg2,.....argn]]: expression
```

看代码示例：

```python
add = lambda a, b: a + b
print(add(1, 2))  # 3
```

`lambda`的一个典型使用场景是排序时指定要比较的关键字：

```python
a = [('小明', 1), ('小红', 4), ('小白', 2), ('小黑', 3)]
a.sort(key=lambda x: x[1])  # 选择列表每个元组的第二项作为比较关键字
print(a)  # [('小明', 1), ('小白', 2), ('小红', 4), ('小黑', 3)]
```
